first class associative data structures seem kinda cool
  - lisp has assoc lists
  - assoc lists are meh
  - hashtables are also meh
  

programming patterns?
	aren't patterns mostly just missing features?
		mostly, but probably not always
			when not?
				the patterns not implemented by Norvig?
				simple structural thingies?
					structural?
						like what sits where in an s-exp

problems of marrying to acyclic data structures
problems of mutability
	can break stuff outside of scope

IDEs
	vim, emacs, wonky stuff
	bloated IDEs

tests
	in language without proofs tests are mostly concerned with making sure that
		the program doesn't do what we wouldn't want it to do
	natural language descriptions before tests
	describe input and output
		in imperative languages - including state

bugs
	tests!!!
	learn from important bugs
		how did I make it?
		how did I find it?
	learn from bugs thay

big bugs
	that thread bug
	big ABC bug
		what?
		how I made it
			trying to be smart before figuring out how ABC really works
		how I found it
	big SnC bug
		calling gc in function that has "Cell" type arguments, which got corrupted
			also because of premature optimization?

small bugs that could've been big
	SnC defs bug
		similar to big SnC bug

just bugs
	ABC off by one
		what?
			allocating when heap full
stumps
	big bugs	

==================================================
OOP

	associating function with one of it's arguments datatype
		type semantically
		instance syntactically
	object in ontology and grammar 

it's almost like associating functions with and instance of one of its arguments' datatype
and generalizing it afterwards

mathematical description of an object
  a compound datatype
  methods
    functions
    associated namespace
  encapsulation
  inheritance
  polymorphism

nail-oriented carpentry

I have nothing against using a lot of nails
What I find foolish is "Let's approach the problem in such a way that we can use nails to solve it"

all abstractions have their cost

taxonomy

people might like it because it feels like they're doing stuff thats forgiving

application of a tool can't become a metric

spurious instntiation

state

hiding state

"it's like real world"
  it's like how you talk about stuff in natural language
		
javaisms
  forcing OOP
  short funcitons
  long names

getters & setters
  aren't they useful for wrappers?
    references instead?
enforcing encapsulation to walk around it
objects with no data

names should fit the mental context
long names are better if you have to recall from far away
short names are better if you use them many times close by

top-down, bottom-up - pn, rpn

mutability and object persistance

single dispatch is easy

objects should be called cells or plants or creatures or whatever

==================================================
FUNCTIONAL PROGRAMMING

it's less dogmatic than OOP

it's not function-oriented

you don't do church numerals

intuitiveness of imperative programming

thinking hard about simple problems

==================================================
ABSOLUTELY IDIOTIC PROGRAMMING

absolutely idiotic approach to generating quality through intellectual work

When evaluated against all that can be known,
you are not smart, I am not smart, neither was John von Neumann, neither is any being
whose problem solving skills are above our comprehesion.

foolish stuff
  nail oriented carpentry
  implicit type conversion
    when it's not bad
      numbers
      bytestring -> unicode?

intuition and reason

what are you trying to be smart for?
why do you think that's smart?

stupid to smart is easier than smart to smart

making you less idiotic if it won't make you more foolish

being unwilling to learn is foolish

deleting all old source files is foolish

being bold is not necessarily foolish

minimizing cognitive load to solve the problem well

shifting goalposts
  maybe theye were in the wrong place?

know when you are shifting goalposts

silliness is foolishness minus the bad stuff

stop writing classes
stop even writing functions or loops

consider the cost of translation between abstractions

in functional languages the easiest abstraction to translate from might not be the default
it may be a monad or something

when is it useful to do a single use procedure?
  getting in the way of context

stuff like "which arguments do I need"

a snippet's ugliness might depend on its surroundings

You'll be lazy anyway

fixation on immutability considered harmful
mutating a dict
  it's not meant to be 'state'

beauty

consider the value in the ugly

don't do 


==================================================
TECH

sexps vs text

what databases are really for
not for providing datastructures
they are for abstracting away the logistics of data storage
  rly?


